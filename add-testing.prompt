# Add Unit Testing to Azure Cosmos DB MongoDB API JavaScript Samples Repository

## Overview
Add comprehensive unit testing to this Azure Cosmos DB MongoDB API JavaScript samples repository using Vitest. This repository contains multiple workspace examples demonstrating various MongoDB operations against Azure Cosmos DB.

## Repository Structure
This is a monorepo with multiple workspaces (numbered directories) containing MongoDB/Cosmos DB code examples:
- Each workspace typically contains an `index.js` file with an exported `main()` function
- The `280-aggregation` workspace contains multiple `.js` files (no `index.js`) with exported `main()` functions
- All workspaces use the MongoDB driver to connect to Azure Cosmos DB
- Code uses environment variables for database connection strings

## Testing Requirements

### Test Framework & Coverage
- Use **Vitest** as the testing framework
- Configure **coverage reporting** using c8/v8 coverage (built into Vitest)
- Track test coverage across all tested workspaces
- Create test reports for analysis

### Test Structure
- Create testing in its own `/test` package in the repository root
- Do NOT modify any original source files
- Create individual test files for each workspace (e.g., `test/001-quickstart.test.js`)
- Test all workspaces that have an `index.js` file with an exported `main()` function
- For workspaces without `index.js`, find any `.js` files that export `main()` and create tests for those

### Mocking Strategy
- **Mock the MongoDB client** and all database operations
- **Mock environment variables** - do not require actual Azure Cosmos DB connection strings
- For each mocked operation:
  - Provide expected returned objects
  - Verify received function calls
  - Verify expected parameters passed to functions
  - Verify expected data structures

### Test Scope
- **Validate main scenarios** in each workspace's `main()` function
- Focus on testing the **code logic and flow**, not external dependencies
- This is a **sample repository** - tests should validate the written code, not extensive error handling or production-level scenarios
- Do not test different scenarios or edge cases beyond the main happy path

### Expected Workspaces to Test
Based on standard structure, test these workspaces:
- `001-quickstart` - Basic CRUD operations
- `101-client-connection-string` - Client connection
- `200-admin` - Server administration
- `201-does-database-exist` - Database existence check
- `202-get-doc-count` - Document counting
- `203-insert-doc` - Document insertion
- `225-get-collection-indexes` - Index management
- `250-upsert-doc` - Document upsert
- `251-bulk_write` - Bulk operations
- `252-insert-many` - Bulk data import
- `275-find` - Query operations
- `280-aggregation` - Aggregation pipeline (test both `.js` files)
- `290-delete-doc` - Document deletion
- `299-drop-collection` - Collection dropping
- `300-drop-database` - Database dropping

### Implementation Guidelines
1. **Setup**: Create `/test` package with its own `package.json`
2. **Dependencies**: Install Vitest and any required mocking libraries
3. **Configuration**: Configure Vitest with coverage reporting
4. **Individual Tests**: Create one test file per workspace
5. **Mocking**: Mock MongoDB client, database, and collection operations
6. **Environment**: Mock `process.env.AZURE_COSMOS_DB_MONGODB_CONNECTION_STRING`
7. **Validation**: Verify function calls, parameters, and return values
8. **Coverage**: Generate and display coverage reports
9. **Automation**: All tests must run in non-interactive mode for CI/CD automation - no watch mode or manual input required

### Error Handling
If any original files are not testable or have issues:
- Report the specific problems encountered
- Suggest simple solutions to make files testable
- Remember this is sample code, not production code
- Recommend minimal changes that maintain code intent

## Success Criteria
- All testable workspaces have corresponding unit tests
- All tests pass and validate main scenario logic
- Mocks properly simulate database operations without external dependencies
- Coverage reports show comprehensive test coverage
- Test suite can be run independently without requiring Azure resources